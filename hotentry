#!/usr/bin/env perl
package Hatena::HotEntry;
use Mouse;

with 'MouseX::Getopt';

our $VERSION = '0.01';

use LWP::UserAgent;
use XML::RSS::LibXML;

has 'threshold' => (
    traits => [ 'Getopt' ],
    is => 'rw',
    isa => 'Int',
    default => 3,
    cmd_aliases => ['t'],
    documentation => "threshold of Hatena bookmark",
);

has 'limit' => (
    traits => [ 'Getopt' ],
    is => 'rw',
    isa => 'Int',
    default => 10,
    cmd_aliases => ['l'],
    documentation => "limit of printing entries",
);

has '_key' => (
    accessor => 'key',
    isa => 'Str',
);

has '_ua' => (
    accessor => 'ua',
    isa => 'LWP::UserAgent',
    lazy_build => 1,
);

sub _build__ua {
    LWP::UserAgent->new(
        agent => __PACKAGE__ . "/$VERSION",
        env_proxy => 1,
    );
}

has '_rss' => (
    accessor => 'rss',
    isa => 'XML::RSS::LibXML',
    lazy_build => 1,
);

sub _build__rss {
    XML::RSS::LibXML->new();
}

has '_infos' => (
    accessor => 'infos',
    isa => 'ArrayRef[HashRef]',
    default => sub {
        +[];
    },
);

__PACKAGE__->meta->make_immutable;

no Mouse;

use Carp qw(croak);
use Encode;
use URI::Escape;

sub run {
    my ($self, $key) = @_;

    die $self->usage unless defined $key;
    $self->key(decode_utf8($key));

    my $url = $self->_entry_url();
    my $content_ref = $self->_get_content_ref($url);

    $self->_parse_rss($content_ref);
    $self->_print;
}

sub _parse_rss {
    my ($self, $content_ref) = @_;

    $self->rss->parse($$content_ref);

    for my $item (@{$self->rss->{'items'}}) {
        push @{$self->infos}, {
            title => $item->{'title'},
            link  => $item->{'link'},
            description => $item->{'description'},
            count => $item->{hatena}->{bookmarkcount},
        };
    }
}

sub _entry_url {
    my $self = shift;

    my ($key, $threshold) = ($self->key, $self->threshold);
    $key = uri_escape_utf8($key);

    my $fmt = 'http://b.hatena.ne.jp/search/tag?q=%s&users=%d&mode=rss';
    sprintf $fmt, $key, $threshold;
}

sub _get_content_ref {
    my ($self, $url) = @_;

    my $res = $self->ua->get($url);
    if ($res->is_error) {
        croak "Can't download $url ", $res->status_line;
    }

    \$res->decoded_content;
}

sub _print {
    my $self = shift;

    my $i = 1;
    my $limit = $self->limit <= @{$self->infos}
        ? ($self->limit - 1) :(scalar @{$self->infos} - 1);
    for my $info (@{$self->infos}[0..$limit]) {
        printf "%2d: %s [%d]\n",
            $i++, encode_utf8($info->{'title'}), $info->{count};
    }
}

1;

package main;
use strict;
use warnings;

unless (caller) {
    my $app = Hatena::HotEntry->new_with_options();
    $app->run(shift @{$app->extra_argv});
}
